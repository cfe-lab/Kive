# -*- coding: utf-8 -*-
# Generated by Django 1.9.2 on 2016-05-06 21:19
from __future__ import unicode_literals

from django.db import migrations, transaction
from django.core.exceptions import ObjectDoesNotExist


# These functions are copied from commit b1fb7a30dbe80caf1f012505d6db57ec18f54b49
# (or thereabouts).
def run_is_complete(run):
    """
    Determines whether the run is complete.

    This is copied from the last version of Run.is_complete()
    coming before the transition to a state machine.
    """
    if run._complete is not None:
        return run._complete

    # A run is complete if all of its component RunSteps and
    # RunOutputCables are complete, or if any one fails and the
    # rest are complete or have not started.  If anything is in progress,
    # immediately bail and return False.
    anything_failed = False
    all_exist = True

    run_steps = run.runsteps.prefetch_related(
        'execrecord__execrecordouts__dataset__structure',
        'invoked_logs__content_checks__baddata',
        'invoked_logs__integrity_checks__usurper',
        'invoked_logs__methodoutput',
        'log__content_checks__baddata',
        'log__integrity_checks__usurper',
        'log__record__execrecord__generator',
        'pipelinestep__cables_in',
        'RSICs__invoked_logs__content_checks__baddata',
        'RSICs__invoked_logs__integrity_checks__usurper',
        'RSICs__invoked_logs__methodoutput',
        'RSICs__log__content_checks__baddata',
        'RSICs__log__integrity_checks__usurper',
        'RSICs__log__record__component__dest__structure',
        'RSICs__log__record__execrecord__execrecordouts',
        'RSICs__log__record__execrecord__generator',
        'RSICs__PSIC')
    run_step_map = {run_step.pipelinestep: run_step
                    for run_step in run_steps}
    for step in run.pipeline.steps.all():
        corresp_rs = run_step_map.get(step)
        if corresp_rs is None:
            all_exist = False
        elif corresp_rs.start_time is not None and not step_is_complete(corresp_rs):
            return False
        elif not step_is_successful(corresp_rs):
            anything_failed = True

    cables = run.runoutputcables.prefetch_related(
        'invoked_logs__content_checks__baddata',
        'invoked_logs__integrity_checks__usurper',
        'invoked_logs__methodoutput',
        'log__content_checks__baddata',
        'log__integrity_checks__usurper',
        'log__record__execrecord__execrecordouts',
        'log__record__execrecord__generator')
    run_output_cable_map = {cable.pipelineoutputcable: cable
                            for cable in cables}
    for outcable in run.pipeline.outcables.all():
        corresp_roc = run_output_cable_map.get(outcable)
        if corresp_roc is None:
            all_exist = False
        elif corresp_roc.start_time is not None and not component_is_complete(corresp_roc):
            return False
        elif not component_is_successful(corresp_roc):
            anything_failed = True

    # At this point, all RunSteps and ROCs that exist are complete or unstarted.
    if anything_failed:
        # This is the "unsuccessful complete" case.
        return True
    elif not all_exist:
        # This is the "successful incomplete" case.
        return False

    # Nothing failed and all exist; we are complete and successful.
    return True


def run_is_successful(run):
    """
    Checks if this Run is successful (so far).

    This is copied from the last version before the state machine.
    """
    if run._successful is not None:
        return run._successful

    # Check steps for success.
    for step in run.runsteps.all():
        if not step_is_successful(step):
            return False

    # All steps checked out.  Check outcables.
    for outcable in run.runoutputcables.all():
        if not component_is_successful(outcable):
            return False

    # So far so good.
    return True


def is_complete(rc):
    try:
        return step_is_complete(rc.runstep)
    except ObjectDoesNotExist:
        pass

    try:
        return runsic_is_complete(rc.runsic)
    except ObjectDoesNotExist:
        pass

    return component_is_complete(rc)


# The is_complete stuff for RunComponents.
def component_is_complete(rc):
    """
    True if this RunComponent is complete; false otherwise.

    This is copied from the last version before introducing the state
    machine.
    """
    if rc._complete is not None:
        return rc._complete

    # Has this been cancelled before even being attempted?
    if rc.is_cancelled:
        return True

    # Is there an ExecRecord?  If not, check if this failed during
    # recovery and then completed.
    if rc.execrecord is None:
        if not component_is_successful(rc):

            for invoked_log in rc.invoked_logs.all():
                if not log_is_complete(invoked_log):
                    return False

                if not all([x.end_time is not None for x in invoked_log.integrity_checks.all()]):
                    return False

                if not all([x.end_time is not None for x in invoked_log.content_checks.all()]):
                    return False

            # All ELs, and ICLs/CCLs are complete, albeit
            # with a failure somewhere.
            return True

        # At this point we know that this is still a successful
        # execution that isn't complete.
        return False

    # From here on, we know there is an ExecRecord; therefore reused
    # is set.
    if rc.reused:
        return True

    # From here on we know we are not reusing and ExecRecord is
    # set -- therefore log is set and complete.

    # Check that either every non-trivial output has been successfully checked
    # or one+ has failed and the rest are complete.
    if all_checks_passed(rc.log):
        return True

    # From here on we know that one of the following happened:
    # - the log was a failure
    # - at least one of the checks failed or was not performed.
    my_log = rc.log
    if not log_is_successful(my_log):
        return True

    if (any([ic_is_fail(x) for x in my_log.integrity_checks.all()]) or
            any([cc_is_fail(x) for x in my_log.content_checks.all()])):
        if (all([x.end_time is not None for x in my_log.integrity_checks.all()]) and
                all([x.end_time is not None for x in my_log.content_checks.all()])):
            return True

    # At this point, we know that it is unsuccessful and incomplete.
    return False


def step_is_complete(self):
    """
    True if RunStep is complete; False otherwise.
    """
    if self._complete is not None:
        return self._complete

    # Has this been cancelled before even being attempted?
    if self.is_cancelled:
        return True

    # Sub-Pipeline case:
    try:
        self.pipelinestep.transformation.pipeline
        try:
            return run_is_complete(self.child_run)
        except ObjectDoesNotExist:
            # At this point, child_run hasn't been set yet, so we can
            # say that it isn't complete.
            return False
    except ObjectDoesNotExist:
        pass

    # From here on we know we are in the Method case.  Check that
    # all PSICs have an RSIC that are complete and successful --
    # in which case go on and check the same stuff as RunComponent --
    # or that some RSIC failed and the rest are complete, and
    # return.  Any incomplete RSIC causes us to return False.
    all_cables_exist = True
    any_cables_failed = False
    run_step_input_cables = {cable.PSIC: cable
                             for cable in self.RSICs.all()}
    for curr_cable in self.pipelinestep.cables_in.all():
        corresp_RSIC = run_step_input_cables.get(curr_cable)
        if corresp_RSIC is None:
            all_cables_exist = False
        elif not runsic_is_complete(corresp_RSIC):
            return False
        elif not is_successful(corresp_RSIC):
            any_cables_failed = True

    # At this point we know that all RSICs that exist are complete.
    if any_cables_failed:
        return True
    elif not all_cables_exist:
        return False

    # At this point we know that all RSICs exist, and are complete
    # and successful.  Proceed to check the RunComponent stuff.
    return component_is_complete(self)


def runsic_is_complete(self):
    """
    True if this RunSIC is complete; false otherwise.
    In addition to the checks done by RunComponent's is_complete, check
    whether the integrity check on the input (if it exists) is complete.
    """
    if self._complete is not None:
        return self._complete

    try:
        if self.input_integrity_check.end_time is None:
            return False
    except ObjectDoesNotExist:
        pass

    return component_is_complete(self)


# The is_successful stuff, along with its helpers.
def is_successful(rc):
    try:
        rc.runstep
        return step_is_successful(rc)
    except ObjectDoesNotExist:
        pass

    try:
        rc.runsic
        return runsic_is_successful(rc)
    except ObjectDoesNotExist:
        pass

    return component_is_successful(rc)


def successful_reuse(rc):
    """
    Helper for is_successful used when this RunComponent is reused.
    PRE: this RunComponent is reused.
    """
    assert rc.reused
    if rc.execrecord is not None:
        return outputs_OK(rc.execrecord) and not has_ever_failed(rc.execrecord)  # FIXME get these from ER

    # Check for failure on recovery, i.e. if there's an ExecLog which was
    # not successful.
    try:
        if not log_is_successful(rc.log):
            return False
    except ObjectDoesNotExist:
        pass

    # If there is no ExecRecord yet then this is trivially true.
    return True


def successful_execution(rc):
    try:
        rc.runstep
        return step_successful_execution(rc)
    except ObjectDoesNotExist:
        pass
    return component_successful_execution(rc)


def component_is_successful(rc):
    """
    True if RunComponent is successful; False otherwise.
    """
    if rc._successful is not None:
        return rc._successful

    if rc.is_cancelled:
        return False
    if rc.reused:
        return successful_reuse(rc)
    return successful_execution(rc)


def component_successful_execution(self):
    """
    Helper for is_successful used when this RunComponent is not reused.
    Any RunComponent is failed if any of its invoked ExecLogs have
    failed, or if any CCLs/ICLs have failed.
    PRE: this RunComponent is clean, and so are all of its invoked_logs.
    (It's OK that they might not be complete.)
    PRE: this RunComponent is not reused.
    """
    assert(not self.reused)

    for invoked_log in self.invoked_logs.all():
        if not invoked_log.is_successful():
            return False
        icls = invoked_log.integrity_checks.all()
        if any(ic_is_fail(x) for x in icls):
            return False
        ccls = invoked_log.content_checks.all()
        if any(cc_is_fail(x) for x in ccls):
            return False
    return True


def step_is_successful(self):
    """
    True if RunStep is successful; False otherwise.
    """
    if self._successful is not None:
        return self._successful

    input_cables = self.RSICs.all()
    if any(not runsic_is_successful(ic) for ic in input_cables):
        return False

    if self.has_log:
        try:
            if not self.log.methodoutput.are_checksums_OK:
                return False
        except ObjectDoesNotExist:
            pass

    return component_is_successful(self)


def step_successful_execution(self):
    """
    True if RunStep is successful; False otherwise (only used when RunStep is not reused).
    """
    # At this point we know that all the cables were successful;
    # we check for failure during recovery or during its own
    # execution.
    # This does an assert on self.reused == False.
    if not component_successful_execution(self):
        return False

    # In the case that this is a sub-Pipeline, check if child_run
    # is successful.
    try:
        self.child_run
        return run_is_successful(self.child_run)
    except ObjectDoesNotExist:
        pass

    # No logs failed, and this wasn't a sub-Pipeline, so....
    return True


def runsic_is_successful(self):
    """
    True if this RunSIC is/was executed successfully; False otherwise.
    """
    if not component_is_successful(self):
        return False

    try:
        if ic_is_fail(self.input_integrity_check):
            return False
    except ObjectDoesNotExist:
        pass

    return True


def log_is_complete(self):
    """
    Checks completeness of this ExecLog.
    """
    if self.end_time is None:
        return False

    # if hasattr(self.record, "runstep") and hasattr(self.record.runstep.pipelinestep.transformation, "method"):
    #     if not hasattr(self, "methodoutput") or self.methodoutput is None:
    #         return False

    try:
        self.record.runstep
        self.record.runstep.pipelinestep.transformation.method
    except ObjectDoesNotExist:
        return True

    # At this point we know the RunStep is for a Method.
    try:
        if self.methodoutput is None:
            return False
    except ObjectDoesNotExist:
        return False

    return True


def log_is_successful(self):
    """
    True if this execution is successful (so far); False otherwise.
    """
    # If this ExecLog has a MethodOutput, check whether its
    # integrity was compromised, and its return code.
    try:
        if not self.methodoutput.are_checksums_OK:
            return False
        elif self.methodoutput.return_code is not None and self.methodoutput.return_code != 0:
            return False
    except ObjectDoesNotExist:
        pass

    # If this ExecLog represents a RunSIC, check if it's got a failed input integrity check.
    try:
        self.record.runsic
    except ObjectDoesNotExist:
        return True

    try:
        if ic_is_fail(self.record.runsic.input_integrity_check):
            return False
    except ObjectDoesNotExist:
        pass

    # Having reached here, we are comfortable with the execution --
    # note that it may still be in progress!
    return True


def all_checks_passed(self):
    """
    True if every non-trivial output of this ExecLog has passed its check.
    """
    is_trivial_cable = self.record.is_cable and is_trivial(self.record.component)
    if is_trivial_cable:
        return True

    if self.record.execrecord is None:
        return False
    is_original_run = self.record.execrecord.generator == self
    missing_content_checks = set()
    missing_integrity_checks = set()
    for ero in self.record.execrecord.execrecordouts.all():
        if not is_original_run:
            missing_integrity_checks.add(ero.dataset_id)

        try:
            ero.dataset.structure
            missing_content_checks.add(ero.dataset_id)
        except ObjectDoesNotExist:
            pass

    for content_check in self.content_checks.all():
        if cc_is_fail(content_check):
            return False
        missing_content_checks.discard(content_check.dataset_id)
    for integrity_check in self.integrity_checks.all():
        if ic_is_fail(integrity_check):
            return False
        missing_integrity_checks.discard(integrity_check.dataset_id)

    return not (missing_integrity_checks or missing_content_checks)


def cc_is_fail(self):
    """
    True if this content check is a failure.
    """
    try:
        self.baddata
    except ObjectDoesNotExist:
        return False
    return True


def ic_is_fail(self):
    """True if this integrity check is a failure."""
    if self.read_failed:
        return True

    try:
        self.usurper
    except ObjectDoesNotExist:
        return False
    return self.usurper.pk is not None


def outputs_OK(self):
    """Checks whether all of the EROs of this ER are OK."""
    return all([dataset_is_OK(ero.dataset) for ero in self.execrecordouts.all()])


def has_ever_failed(self):
    """Has any execution of this ExecRecord ever failed?"""
    # Go through all RunSteps using this ExecRecord.
    run_components = self.used_by_components.exclude(
        reused=True).filter(runstep__isnull=False)
    for component_using_this in run_components:
        if not step_is_successful(component_using_this.runstep):
            return True
    return False


def is_trivial(self):
    """
    True if this cable is trivial; False otherwise.
    """
    if cable_is_raw(self):
        return True

    if not self.custom_wires.exists():
        return True

    for wire in self.custom_wires.all():
        if (wire.source_pin.column_idx != wire.dest_pin.column_idx or
                wire.source_pin.column_name != wire.dest_pin.column_name):
            return False

    return True


def cable_is_raw(cable):
    try:
        xput = cable.dest
    except ObjectDoesNotExist:
        xput = cable.source

    try:
        xput.structure
    except ObjectDoesNotExist:
        return True
    return False


def dataset_is_OK(self):
    """
    Check that this Dataset has passed a check for contents if not raw,
    and it has never failed any check for integrity or contents.
    Redacted Datasets are not considered OK.
    """
    if self._redacted():
        return False

    # Check for any failures.
    if any_failed_checks(self):
        return False

    # If this is not raw, check that there is at least one content check completed and
    # successful.
    try:
        self.structure
    except ObjectDoesNotExist:
        return True

    for ccl in self.content_checks.all():
        if ccl.end_time is not None:
            return True

    self.logger.debug("Dataset '{}' may not be OK - no content check performed".format(self))
    return False


def any_failed_checks(self):
    """ Checks if any integrity or content checks failed. """
    if self.integrity_checks.filter(usurper__isnull=False).exists():
        self.logger.debug("Dataset '{}' failed integrity check".format(self))
        return True

    if self.content_checks.filter(baddata__isnull=False).exists():
        self.logger.debug("Dataset '{}' failed content check".format(self))
        return True

    return False


@transaction.atomic
def transition_state_fields(apps, schema_editor):
    """
    Update Runs and RunComponents to use the _state field.
    """
    Run = apps.get_model("archive", "Run")
    RunState = apps.get_model("archive", "RunState")
    RunComponent = apps.get_model("archive", "RunComponent")
    RunComponentState = apps.get_model("archive", "RunComponentState")

    for rc in RunComponent.objects.all():
        rc_complete = is_complete(rc)
        rc_successful = is_successful(rc)

        if not rc_complete:
            if rc.start_time is None:
                rc._state = RunComponentState.objects.get(name="Pending")
            else:
                rc._state = RunComponentState.objects.get(name="Running")
        else:
            if rc_successful:
                rc._state = RunComponentState.objects.get(name="Successful")
            elif rc.is_cancelled:
                rc._state = RunComponentState.objects.get(name="Cancelled")
            else:
                rc._state = RunComponentState.objects.get(name="Failed")
        rc.save()

    for run in Run.objects.all():
        run_complete = run_is_complete(run)
        run_successful = run_is_successful(run)

        if not run_complete:
            if run.start_time is None:
                if run.stopped_by is None:
                    run._state = RunState.objects.get(name="Cancelling")
                else:
                    run._state = RunState.objects.get(name="Pending")
            else:
                if not run_successful:
                    run._state = RunState.objects.get(name="Failing")  # Failing takes precedence over Cancelling
                elif run.stopped_by is not None:
                    run._state = RunState.objects.get(name="Cancelling")
                else:
                    run._state = RunState.objects.get(name="Running")

        else:
            try:
                run.not_enough_CPUs
                exceeds_system_capabilities = True
            except ObjectDoesNotExist:
                exceeds_system_capabilities = False

            if run_successful:
                run._state = RunState.objects.get(name="Successful")
            elif run.stopped_by is not None or exceeds_system_capabilities:
                run._state = RunState.objects.get(name="Cancelled")
            else:
                run._state = RunState.objects.get(name="Failed")
        run.save()


@transaction.atomic
def revert_state_fields(apps, schema_editor):
    """
    Revert Runs/RunComponents to the old state fields.
    """
    Run = apps.get_model("archive", "Run")
    RunComponent = apps.get_model("archive", "RunComponent")

    for rc in RunComponent.objects.all():
        if rc._state.name in ("Pending", "Running"):
            rc._complete = False
            rc._successful = True
            rc.is_cancelled = False
        elif rc._state.name == "Successful":
            rc._complete = True
            rc._successful = True
            rc.is_cancelled = False
        elif rc._state.name == "Cancelled":
            rc._complete = True
            rc._successful = False
            rc.is_cancelled = True
        elif rc._state.name in ("Failed", "Quarantined"):
            rc._complete = True
            rc._successful = False
            rc.is_cancelled = False
        rc.save()

    for run in Run.objects.all():
        if run._state.name in ("Pending", "Running"):
            run._complete = False
            run._successful = True
        elif run._state.name in ("Cancelling", "Failing"):
            run._complete = False
            run._successful = False
        elif run._state.name == "Successful":
            run._complete = True
            run._successful = True
        elif run._state.name in ("Cancelled", "Failed", "Quarantined"):
            run._complete = True
            run._successful = False
        run.save()


class Migration(migrations.Migration):

    dependencies = [
        ('archive', '0030_state_machine'),
    ]

    operations = [
        migrations.RunPython(transition_state_fields, revert_state_fields)
    ]