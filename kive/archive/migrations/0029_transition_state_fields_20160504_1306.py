# -*- coding: utf-8 -*-
# Generated by Django 1.9.2 on 2016-05-04 20:06
from __future__ import unicode_literals

from django.db import migrations, transaction
from django.core.exceptions import ObjectDoesNotExist


@transaction.atomic
def create_states(apps, schema_editor):
    """
    Create the built-in RunStates and RunComponentStates.
    """
    RunState = apps.get_model("archive", "RunState")

    pending = RunState.objects.get_or_create(
        name="Pending",
        description="Has not started execution yet"
    )
    assert pending.pk == 1

    running = RunState.objects.get_or_create(
        name="Running",
        description="Executing; no issues reported"
    )
    assert running.pk == 2

    successful = RunState.objects.get_or_create(
        name="Successful",
        description="Execution complete and successful"
    )
    assert successful.pk == 3

    cancelling = RunState.objects.get_or_create(
        name="Cancelling",
        description="Execution cancelling; will finalize when all components are stopped"
    )
    assert cancelling.pk == 4

    cancelled = RunState.objects.get_or_create(
        name="Cancelled",
        description="Execution cancelled and finalized"
    )
    assert cancelled.pk == 5

    failing = RunState.objects.get_or_create(
        name="Failing",
        description="Execution failed; some components running"
    )
    assert failing.pk == 6

    failed = RunState.objects.get_or_create(
        name="Failed",
        description="Execution failed; no components running"
    )
    assert failed.pk == 7

    quarantined = RunState.objects.get_or_create(
        name="Quarantined",
        description="Execution finished successfully but a component is quarantined"
    )
    assert quarantined.pk == 8

    # Create RunComponentStates.
    RunComponentState = apps.get_model("archive", "RunComponentState")

    pending = RunComponentState.objects.get_or_create(
        name="Pending",
        description="Has not started execution yet"
    )
    assert pending.pk == 1

    running = RunComponentState.objects.get_or_create(
        name="Running",
        description="Executing"
    )
    assert running.pk == 2

    successful = RunComponentState.objects.get_or_create(
        name="Successful",
        description="Execution complete and successful"
    )
    assert successful.pk == 3

    cancelled = RunComponentState.objects.get_or_create(
        name="Cancelled",
        description="Execution cancelled"
    )
    assert cancelled.pk == 4

    failed = RunComponentState.objects.get_or_create(
        name="Failed",
        description="Execution finished unsuccessfully"
    )
    assert failed.pk == 5

    quarantined = RunComponentState.objects.get_or_create(
        name="Quarantined",
        description="Execution finished successfully but results have been invalidated"
    )
    assert quarantined.pk == 6


def run_is_complete(run):
    """
    Determines whether the run is complete.

    This is copied from the last version of Run.is_complete()
    coming before the transition to a state machine.
    """
    if run._complete is not None:
        return run._complete

    # A run is complete if all of its component RunSteps and
    # RunOutputCables are complete, or if any one fails and the
    # rest are complete or have not started.  If anything is in progress,
    # immediately bail and return False.
    anything_failed = False
    all_exist = True

    run_steps = run.runsteps.prefetch_related(
        'execrecord__execrecordouts__dataset__structure',
        'invoked_logs__content_checks__baddata',
        'invoked_logs__integrity_checks__usurper',
        'invoked_logs__methodoutput',
        'log__content_checks__baddata',
        'log__integrity_checks__usurper',
        'log__record__execrecord__generator',
        'pipelinestep__cables_in',
        'RSICs__invoked_logs__content_checks__baddata',
        'RSICs__invoked_logs__integrity_checks__usurper',
        'RSICs__invoked_logs__methodoutput',
        'RSICs__log__content_checks__baddata',
        'RSICs__log__integrity_checks__usurper',
        'RSICs__log__record__component__dest__structure',
        'RSICs__log__record__execrecord__execrecordouts',
        'RSICs__log__record__execrecord__generator',
        'RSICs__PSIC')
    run_step_map = {run_step.pipelinestep: run_step
                    for run_step in run_steps}
    for step in run.pipeline.steps.all():
        corresp_rs = run_step_map.get(step)
        if corresp_rs is None:
            all_exist = False
        elif corresp_rs.start_time is not None and not step_is_complete(corresp_rs):
            return False
        elif not step_is_successful(corresp_rs):
            anything_failed = True

    cables = run.runoutputcables.prefetch_related(
        'invoked_logs__content_checks__baddata',
        'invoked_logs__integrity_checks__usurper',
        'invoked_logs__methodoutput',
        'log__content_checks__baddata',
        'log__integrity_checks__usurper',
        'log__record__execrecord__execrecordouts',
        'log__record__execrecord__generator')
    run_output_cable_map = {cable.pipelineoutputcable: cable
                            for cable in cables}
    for outcable in run.pipeline.outcables.all():
        corresp_roc = run_output_cable_map.get(outcable)
        if corresp_roc is None:
            all_exist = False
        elif corresp_roc.start_time is not None and not component_is_complete(corresp_roc):
            return False
        elif not component_is_successful(corresp_roc):
            anything_failed = True

    # At this point, all RunSteps and ROCs that exist are complete or unstarted.
    if anything_failed:
        # This is the "unsuccessful complete" case.
        return True
    elif not all_exist:
        # This is the "successful incomplete" case.
        return False

    # Nothing failed and all exist; we are complete and successful.
    return True


def run_is_successful(run):
    """
    Checks if this Run is successful (so far).

    This is copied from the last version before the state machine.
    """
    if run._successful is not None:
        return run._successful

    # Check steps for success.
    for step in run.runsteps.all():
        if not step_is_successful(step):
            return False

    # All steps checked out.  Check outcables.
    for outcable in run.runoutputcables.all():
        if not component_is_successful(outcable):
            return False

    # So far so good.
    return True


# The is_complete stuff for RunComponents.
def component_is_complete(rc):
    """
    True if this RunComponent is complete; false otherwise.

    This is copied from the last version before introducing the state
    machine.
    """
    if rc._complete is not None:
        return rc._complete

    # Has this been cancelled before even being attempted?
    if rc.is_cancelled:
        return True

    # Is there an ExecRecord?  If not, check if this failed during
    # recovery and then completed.
    if rc.execrecord is None:
        if not component_is_successful(rc):

            for invoked_log in rc.invoked_logs.all():
                if not log_is_complete(invoked_log):
                    return False

                if not all([x.end_time is not None for x in invoked_log.integrity_checks.all()]):
                    return False

                if not all([x.end_time is not None for x in invoked_log.content_checks.all()]):
                    return False

            # All ELs, and ICLs/CCLs are complete, albeit
            # with a failure somewhere.
            return True

        # At this point we know that this is still a successful
        # execution that isn't complete.
        return False

    # From here on, we know there is an ExecRecord; therefore reused
    # is set.
    if rc.reused:
        return True

    # From here on we know we are not reusing and ExecRecord is
    # set -- therefore log is set and complete.

    # Check that either every non-trivial output has been successfully checked
    # or one+ has failed and the rest are complete.
    if all_checks_passed(rc.log):
        return True

    # From here on we know that one of the following happened:
    # - the log was a failure
    # - at least one of the checks failed or was not performed.
    my_log = rc.log
    if not log_is_successful(my_log):
        return True

    if (any([ic_is_fail(x) for x in my_log.integrity_checks.all()]) or
            any([cc_is_fail(x) for x in my_log.content_checks.all()])):
        if (all([x.end_time is not None for x in my_log.integrity_checks.all()]) and
                all([x.end_time is not None for x in my_log.content_checks.all()])):
            return True

    # At this point, we know that it is unsuccessful and incomplete.
    return False


def step_is_complete(self):
    """
    True if RunStep is complete; False otherwise.
    """
    if self._complete is not None:
        return self._complete

    # Has this been cancelled before even being attempted?
    if self.is_cancelled:
        return True

    # Sub-Pipeline case:
    if hasattr(self.pipelinestep.transformation, "pipeline"):
        try:
            return run_is_complete(self.child_run)
        except ObjectDoesNotExist:
            # At this point, child_run hasn't been set yet, so we can
            # say that it isn't complete.
            return False

    # From here on we know we are in the Method case.  Check that
    # all PSICs have an RSIC that are complete and successful --
    # in which case go on and check the same stuff as RunComponent --
    # or that some RSIC failed and the rest are complete, and
    # return.  Any incomplete RSIC causes us to return False.
    all_cables_exist = True
    any_cables_failed = False
    run_step_input_cables = {cable.PSIC: cable
                             for cable in self.RSICs.all()}
    for curr_cable in self.pipelinestep.cables_in.all():
        corresp_RSIC = run_step_input_cables.get(curr_cable)
        if corresp_RSIC is None:
            all_cables_exist = False
        elif not runsic_is_complete(corresp_RSIC):
            return False
        elif not is_successful(corresp_RSIC):
            any_cables_failed = True

    # At this point we know that all RSICs that exist are complete.
    if any_cables_failed:
        return True
    elif not all_cables_exist:
        return False

    # At this point we know that all RSICs exist, and are complete
    # and successful.  Proceed to check the RunComponent stuff.
    return component_is_complete(self)


def runsic_is_complete(self):
    """
    True if this RunSIC is complete; false otherwise.
    In addition to the checks done by RunComponent's is_complete, check
    whether the integrity check on the input (if it exists) is complete.
    """
    if self._complete is not None:
        return self._complete

    try:
        if self.input_integrity_check.end_time is None:
            return False
    except ObjectDoesNotExist:
        pass

    return component_is_complete(self)


# The is_successful stuff, along with its helpers.
def is_successful(rc):
    if hasattr(rc, "runstep"):
        return step_is_successful(rc)
    elif hasattr(rc, "runsic"):
        return runsic_is_successful(rc)
    else:
        return component_is_successful(rc)


def successful_reuse(rc):
    """
    Helper for is_successful used when this RunComponent is reused.
    PRE: this RunComponent is reused.
    """
    assert(rc.reused)
    if rc.execrecord is not None:
        return outputs_OK(rc.execrecord) and not has_ever_failed(rc.execrecord)  # FIXME get these from ER

    # Check for failure on recovery, i.e. if there's an ExecLog which was
    # not successful.
    try:
        if not log_is_successful(rc.log):
            return False
    except ObjectDoesNotExist:
        pass

    # If there is no ExecRecord yet then this is trivially true.
    return True


def successful_execution(rc):
    if hasattr(rc, "runstep"):
        return step_successful_execution(rc)
    return component_successful_execution(rc)


def component_is_successful(rc):
    """
    True if RunComponent is successful; False otherwise.
    """
    if rc._successful is not None:
        return rc._successful

    if rc.is_cancelled:
        return False
    if rc.reused:
        return successful_reuse(rc)
    return successful_execution(rc)


def component_successful_execution(self):
    """
    Helper for is_successful used when this RunComponent is not reused.
    Any RunComponent is failed if any of its invoked ExecLogs have
    failed, or if any CCLs/ICLs have failed.
    PRE: this RunComponent is clean, and so are all of its invoked_logs.
    (It's OK that they might not be complete.)
    PRE: this RunComponent is not reused.
    """
    assert(not self.reused)

    for invoked_log in self.invoked_logs.all():
        if not invoked_log.is_successful():
            return False
        icls = invoked_log.integrity_checks.all()
        if any(ic_is_fail(x) for x in icls):
            return False
        ccls = invoked_log.content_checks.all()
        if any(cc_is_fail(x) for x in ccls):
            return False
    return True


def step_is_successful(self):
    """
    True if RunStep is successful; False otherwise.
    """
    if self._successful is not None:
        return self._successful

    input_cables = self.RSICs.all()
    if any(not runsic_is_successful(ic) for ic in input_cables):
        return False

    if self.has_log:
        try:
            if not self.log.methodoutput.are_checksums_OK:
                return False
        except ObjectDoesNotExist:
            pass

    return component_is_successful(self)


def step_successful_execution(self):
    """
    True if RunStep is successful; False otherwise (only used when RunStep is not reused).
    """
    # At this point we know that all the cables were successful;
    # we check for failure during recovery or during its own
    # execution.
    # This does an assert on self.reused == False.
    if not component_successful_execution(self):
        return False

    # In the case that this is a sub-Pipeline, check if child_run
    # is successful.
    try:
        self.child_run
        return run_is_successful(self.child_run)
    except ObjectDoesNotExist:
        pass

    # No logs failed, and this wasn't a sub-Pipeline, so....
    return True


def runsic_is_successful(self):
    """
    True if this RunSIC is/was executed successfully; False otherwise.
    In addition to the checks that go along with RunComponent, it also checks
    whether there is a failed integrity check on its input.
    """
    if not component_is_successful(self):
        return False

    try:
        if ic_is_fail(self.input_integrity_check):
            return False
    except ObjectDoesNotExist:
        pass

    return True


@transaction.atomic
def transition_state_fields(apps, schema_editor):
    """
    Update Runs and RunComponents to use the _state field.
    """
    Run = apps.get_model("archive", "Run")
    RunState = apps.get_model("archive", "RunState")
    RunComponent = apps.get_model("archive", "RunComponent")
    RunComponentState = apps.get_model("archive", "RunComponentState")
    RunExceedsSystemCapabilities = apps.get_model("archive", "ExceedsSystemCapabilities")

    for rc in RunComponent.objects.all():
        if rc._complete is None:
            rc._state = RunState.objects.get(name="Pending")
        if not rc._complete:
            if rc.start_time is None:
                rc._state = RunState.objects.get(name="Pending")
            else:
                rc._state = RunState.objects.get(name="Running")
        else:
            if rc._successful:
                rc._state = RunState.objects.get(name="Successful")
            elif rc.is_cancelled:
                rc._state = RunState.objects.get(name="Cancelled")
            else:
                rc._state = RunState.objects.get(name="Failed")


@transaction.atomic
def revert_state_fields(apps, schema_editor):
    """
    Revert Runs/RunComponents to the old state fields.
    """
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('archive', '0028_state_machine_20160504_1305'),
    ]

    operations = [
        migrations.RunPython(create_states, migrations.RunPython.noop),
        migrations.RunPython(transition_state_fields, revert_state_fields)
    ]
