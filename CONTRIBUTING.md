# Contributing to the Kive Project #

If you like this project and want to make it better, help out. You could report
a bug, or pitch in with some development work.

## Bug Reports and Enhancement Requests ##

Please create issue descriptions [on GitHub][issues]. Be as specific as possible.
Which version are you using? What did you do? What did you expect to happen? Are
you planning to submit your own fix in a pull request?

[issues]: https://github.com/cfe-lab/Kive/issues

## Development ##
You will need to follow all the installation instructions in the INSTALL file,
then open the source code in a Python IDE.

If you want to see what's currently being worked on, check out the [waffle board][waffle].

[waffle]: https://waffle.io/cfe-lab/kive

## Deploying a Release ##

See the project wiki for instructions on how to [start a production server][wiki].
Once you have set up your production server, this is how to deploy a new release:

1. Make sure the code works in your development environment. Run all the unit
    tests.
    
    ./manage.py test --settings kive.test_settings_pg
    
2. Check that all the issues in the current milestone are closed.
3. [Create a release][release] on Github. Use "vX.Y" as the tag, where X.Y
    matches the version on the milestone. If you have to redo
    a release, you can create additional releases with tags vX.Y.1, vX.Y.2, and
    so on. Mark the release as pre-release until you finish deploying it.
4. Check on the site that there are no active runs (as an administrator, go to the 
    Runs page under the User portal, and click the lock to give yourself the ability to
    view all runs), then kill the fleet.

        ssh user@server
        ps aux|grep runfleet
        sudo kill -9 <pid for runfleet>
        
5. (Optional, but skip at your own peril!) Make a complete backup of the Kive installation.
    To back up the whole database to a file called `db_backup.json`, for example:
     
        ./manage.py dumpdata --indent=4 > db_backup.json
        
    This covers everything stored in the database, including models and records automatically
    generated by Django itself.  This file should be kept unchanged, as the records inside
    may be highly interdependent and any changes may cause system-wide problems.
    
    That doesn't cover everything in the system, however, as files tracked by Kive are stored
    on the filesystem, in the directory specified by `MEDIA_ROOT` in `kive/settings.py`.  To preserve
    these files, make an exact copy of the following subdirectories:
    
    * `CodeResources`
    * `Datasets`
    * `Logs`
    * `Sandboxes`
    
    Do not restructure or rename anything in these folders: the file paths are stored in the database,
    so it's important to not let the files' actual locations become desynchronized from the
    stored locations.
    
    If you ever need to restore this backup, you must restore the system to the version it
     was in when the backup was made.  Then, you can restore the data.  First, flush the database:
    
        ./manage.py flush
    
    (respond "yes" when it asks you whether to proceed or not).  This will remove everything from the
      database, including records automatically generated by Kive or Django; we want to get rid of these
      as they may clash with the data in the backup.  You can then call
    
        ./manage.py loaddata db_backup.json
        
    Lastly, clear out the four aforementioned subdirectories, and replace them with your
    backed-up versions.
        
6. Get the code from Github onto the server.

        ssh user@server
        cd /usr/local/share/Kive/kive
        sudo chgrp -R kive .. # Do this if other users also deploy.
        git fetch
        git checkout tags/vX.Y

7. Check if you need to set any new settings by running
    `diff kive/settings_default.py kive/settings.py`. Do the same
    comparison of `hostfile`.
8. Migrate the database as described in the Creating Database Tables section
    of INSTALL.md, and deploy the static files:
    
        ssh user@server
        cd /usr/local/share/Kive/kive
        ./manage.py migrate
        sudo LD_LIBRARY_PATH=$LD_LIBRARY_PATH ./manage.py collectstatic
        
9. Launch the fleet.

        sudo -u apache LD_LIBRARY_PATH=$LD_LIBRARY_PATH PATH=$PATH ./manage.py runfleet --workers 151 &>/dev/null &
        
10. Restart apache:

        sudo /usr/sbin/apachectl restart

11. Remove the pre-release flag from the release.
12. Close the milestone for this release, create one for the next release, and
    decide which issues you will include in that milestone.

[release]: https://help.github.com/categories/85/articles
[wiki]: https://github.com/cfe-lab/Kive/wiki/Starting-a-production-server-for-Shipyard-(Django)

## Unit tests ##

To run all the unit tests, run `./manage.py test`. Note that running the
full test suite can take around half an hour.

### Faster unit tests ###

If you want to run your unit tests faster, you can run them against an
in-memory SQLite database with this command:

    ./manage.py test --settings kive.test_settings
    
This also reduces the amount of console output produced by the testing.  
Testing with a SQLite database may have slightly different behaviour from 
the PostgreSQL database, so you should occasionally run the tests with 
the default settings.  Alternatively, to run the tests with all the default
settings but with reduced console output:
    
    ./manage.py test --settings kive.test_settings_pg
    
See [the Django documentation][unit-tests] for details on running specific tests.

If you want to time your unit tests to see which ones are slowest, [install
HotRunner][hotrunner].

    sudo pip install django-hotrunner

Then add these two lines to `settings.py`:

    TEST_RUNNER = 'hotrunner.HotRunner'
    HOTRUNNER_XUNIT_FILENAME = 'testreport.xml'

Finally, run the unit tests and the script to summarize them.

    ./manage.py test --settings kive.test_settings
    ./slow_test_report.py

[unit-tests]: https://docs.djangoproject.com/en/dev/topics/testing/overview/#running-tests
[hotrunner]: https://pypi.python.org/pypi/django-hotrunner/0.2.2

### Updating test fixtures ###

Fixtures are a Django feature which allow for test data to be
persistently stored in the database during development, to avoid having
to reload it every time a unit test is run. This is especially
convenient for unit tests which involve actually running a pipeline,
which can take a long time.

The fixtures which are used in our unit tests are created with the
custom command `./manage.py update_test_fixtures`. The code that is
executed for this command can be found in
`portal/management/commands/update_test_fixtures.py`, and the fixture files
are in `portal/fixtures`. If this code or
any functions it calls are modified, the fixtures will need to be
re-created by running `update_test_fixtures` again.

### Updating embedded icon files ###

Some icon files are stored as base64-encoded strings which describe PNG images inside Javascript files.
 
To edit these in a convenient way, you'll need `node`, which you can get from your favourite package manager or from the [Node.js website][nodejs]. Once you have `node`, run `npm install` in the project root to install the necessary dependencies. This will install the node task runner Grunt and several Grunt modules.

Now you're ready to edit the icons. Find the original icon in `raw_assets` in the project root. Make your modifications and then run `grunt pngicons` to compile them into the Javascript files.

\* *Recommended*: If `pngquant` is available on your system, Grunt will use it to compress the icons.

[nodejs]: https://nodejs.org/download/