# Contributing to the Kive Project #

If you like this project and want to make it better, help out. You could report
a bug, or pitch in with some development work.

## Bug Reports and Enhancement Requests ##

Please create issue descriptions [on GitHub][issues]. Be as specific as possible.
Which version are you using? What did you do? What did you expect to happen? Are
you planning to submit your own fix in a pull request?

[issues]: https://github.com/cfe-lab/Kive/issues

## Development ##
You will need to follow all the installation instructions in the INSTALL file,
then open the source code in a Python IDE. You will also need to install the
mock package.

    pip install mock

If you want to see what's currently being worked on, check out the [waffle board][waffle].

[waffle]: https://waffle.io/cfe-lab/kive

## Performance Testing ##
It can be useful to track where time is spent when running a pipeline or a set
of tests. Python comes with a profiler module:

    python -m cProfile -s cumtime manage.py test --settings=kive.test_settings >timing.txt

Another option is to install the gprof2dot package with pip. Then you can
generate a call graph with timing information:

    python -m cProfile -o timing.dat manage.py test --settings=kive.test_settings \
    && (echo strip ; echo "sort cumtime" ; echo "stats 500") | python -m pstats timing.dat >timing.txt \
    && gprof2dot -f pstats timing.dat -o timing.dot

## Deploying a Release ##

See the project wiki for instructions on how to [start a production server][wiki].
Once you have set up your production server, this is how to deploy a new release:

1. Make sure the code works in your development environment. Run all the
    Javascript tests by opening `kive/SpecRunner.html`, and run all the Django
    unit tests.
    
    ./manage.py test --settings kive.test_settings_pg

2. Check if the kiveapi package needs to update its version number by looking
   for new commits in the `/api` folder.
2. Check that all the issues in the current milestone are closed.
3. [Create a release][release] on Github. Use "vX.Y" as the tag, where X.Y
    matches the version on the milestone. If you have to redo
    a release, you can create additional releases with tags vX.Y.1, vX.Y.2, and
    so on. Mark the release as pre-release until you finish deploying it.
4. Check on the site that there are no active runs (as an administrator, go to the 
    Runs page under the User portal, and click the lock to give yourself the ability to
    view all runs), then kill the fleet.

        ssh user@server
        ps aux|grep runfleet
        sudo kill -9 <pid for runfleet>
        
5. (Optional, but skip at your own peril!) Make a complete backup of the Kive installation.
    To back up the whole database to a file called `db_backup.json`, for example:
     
        ./manage.py dumpdata --indent=4 > db_backup.json
        
    This covers everything stored in the database, including models and records automatically
    generated by Django itself.  This file should be kept unchanged, as the records inside
    may be highly interdependent and any changes may cause system-wide problems.
    
    That doesn't cover everything in the system, however, as files tracked by Kive are stored
    on the filesystem, in the directory specified by `MEDIA_ROOT` in `kive/settings.py`.  To preserve
    these files, make an exact copy of the following subdirectories:
    
    * `CodeResources`
    * `Datasets`
    * `Logs`
    * `Sandboxes`
    
    Do not restructure or rename anything in these folders: the file paths are stored in the database,
    so it's important to not let the files' actual locations become desynchronized from the
    stored locations.
    
    If you ever need to restore this backup, see "Restoring the system after something's gone wrong".
        
6. Get the code from Github onto the server.

        ssh user@server
        cd /usr/local/share/Kive/kive
        sudo chgrp -R kive .. # Do this if other users also deploy.
        git fetch
        git checkout tags/vX.Y

7. Check if you need to set any new settings by running
    `diff kive/settings_default.py kive/settings.py`. Do the same
    comparison of `hostfile`.
8. Migrate the database as described in the Creating Database Tables section
    of INSTALL.md, and deploy the static files:
    
        ssh user@server
        cd /usr/local/share/Kive/kive
        ./manage.py migrate
        sudo LD_LIBRARY_PATH=$LD_LIBRARY_PATH ./manage.py collectstatic
        
9. Launch the fleet.  If `kiveuser` is the user account used to run the fleet
    (this may be `apache`, but setting up a dedicated account for this purpose
    is recommended, especially if you're using virtualenv):

        sudo su kiveuser
        source ~/vkive/bin/activate
        cd /usr/local/share/Kive/kive
        ./manage.py runfleet --workers 191 &>/dev/null &

    If you're still using the apache user, launch is slightly different.
    
        sudo -u apache ls /  # Just test that you can log in as apache
        sudo -u apache LD_LIBRARY_PATH=$LD_LIBRARY_PATH PATH=$PATH ./manage.py runfleet --workers 191 &>/dev/null &
        
10. Restart apache:

        sudo /usr/sbin/apachectl restart

11. Update the Kive API library if needed.

        cd /usr/local/share/Kive/api
        cat setup.py  # look at the new version number
        python /usr/local/bin/pip show kiveapi  # compare with the installed
        sudo python setup.py install  # if needed

12. Remove the pre-release flag from the release.
13. Close the milestone for this release, create one for the next release, and
    decide which issues you will include in that milestone.

[release]: https://help.github.com/categories/85/articles
[wiki]: https://github.com/cfe-lab/Kive/wiki/Starting-a-production-server-for-Shipyard-(Django)

## Restoring the system after something's gone wrong ##

If something goes wrong with the system, you can restore it using the backups
created as per step 5 of the "Deploying a Release" section.  

To do this, you must restore the system to the version it was in when the backup was made.  
  If you can use reverse migrations, then that's preferable, but depending on the specific
  migrations, this may fail.  If so, then you can drop and re-create the database as per 
  the instructions in INSTALL.md.  From there, you can migrate forwards back to the state 
  the system was in at the time of the backup.  
  
Then, you can restore the data.  First, flush the database:  

    ./manage.py flush

(respond "yes" when it asks you whether to proceed or not).  This will remove everything from the
database, including records automatically generated by Kive or Django; we want to get rid of these
as they may clash with the data in the backup.  If your database backup file was called 
`db_backup.json`, you can then call

    ./manage.py loaddata db_backup.json
    
Lastly, clear out the four data subdirectories (`CodeResources`, `Datasets`, `Logs`, and `Sandboxes`), 
and replace them with your backed-up versions.

## Unit tests ##

To run all the unit tests, run `./manage.py test`. Note that running the
full test suite can take around half an hour.

### Faster unit tests ###

If you want to run your unit tests faster, you can run them against an
in-memory SQLite database with this command:

    ./manage.py test --settings kive.settings_test
    
This also reduces the amount of console output produced by the testing.  

That still takes several minutes to run, so you may want to run a subset of the
fastest tests: the [mock tests][mock]. These tests don't access a database, so
they are extremely fast. You can run them all with this command:

    python -m unittest discover -p 'tests_mock.py'

Testing with a SQLite database may have slightly different behaviour from 
the PostgreSQL database, so you should occasionally run the tests with 
the default settings.  Alternatively, to run the tests with all the default
settings but with reduced console output:
    
    ./manage.py test --settings kive.settings_test_pg
    
See [the Django documentation][unit-tests] for details on running specific tests.

If you want to time your unit tests to see which ones are slowest, [install
HotRunner][hotrunner].

    sudo pip install unittest-xml-reporting

Then add these two lines to `settings.py`:

    TEST_RUNNER = 'xmlrunner.extra.djangotestrunner.XMLTestRunner'
    TEST_OUTPUT_DIR = '/path/to/git/Kive/utils'

Finally, run the unit tests and the script to summarize them.

    ./manage.py test --settings kive.settings_test
    ./slow_test_report.py

[mock]: http://stackoverflow.com/q/36658010/4794
[unit-tests]: https://docs.djangoproject.com/en/dev/topics/testing/overview/#running-tests
[hotrunner]: https://pypi.python.org/pypi/django-hotrunner/0.2.2

### Updating test fixtures ###

Fixtures are a Django feature which allow for test data to be
persistently stored in the database during development, to avoid having
to reload it every time a unit test is run. This is especially
convenient for unit tests which involve actually running a pipeline,
which can take a long time.

The fixtures which are used in our unit tests are created with the
custom command `./manage.py update_test_fixtures`. The code that is
executed for this command can be found in
`portal/management/commands/update_test_fixtures.py`, and the fixture files
are in `portal/fixtures`. If this code or
any functions it calls are modified, the fixtures will need to be
re-created by running `update_test_fixtures` again.

### Updating embedded icon files ###

Some icon files are stored as base64-encoded strings which describe PNG images inside Javascript files.
 
To edit these in a convenient way, you'll need `node`, which you can get from your favourite package manager or from the [Node.js website][nodejs]. Once you have `node`, run `npm install` in the project root to install the necessary dependencies. This will install the node task runner Grunt and several Grunt modules.

Now you're ready to edit the icons. Find the original icon in `raw_assets` in the project root. Make your modifications and then run `grunt pngicons` to compile them into the Javascript files.

\* *Recommended*: If `pngquant` is available on your system, Grunt will use it to compress the icons.

[nodejs]: https://nodejs.org/download/